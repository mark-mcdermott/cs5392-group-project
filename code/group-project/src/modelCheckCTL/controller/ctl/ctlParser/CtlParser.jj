options {
STATIC = false;
}

PARSER_BEGIN(CtlParser)
package modelCheckCTL.controller.ctl.ctlParser;

import java.util.Set;
import java.util.HashSet;
import modelCheckCTL.controller.ctl.ctlParser.ParseException;
import modelCheckCTL.model.kripke.Kripke;import modelCheckCTL.model.kripke.State;
import static modelCheckCTL.controller.ctl.CtlUtils.statesWithLabel;
import static modelCheckCTL.util.Util.getLabelsStr;import static modelCheckCTL.util.Util.printStates;

/* clt parser rules approach from https://github.com/pedrogongora/antelope/blob/master/AntelopeCore/src/antelope/ctl/parser/CTLParser.jj, accessed 9/20 */
public class CtlParser {
    private Kripke kripke;

}

PARSER_END(CtlParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
      <NOT: "not">
    | <AND: "and">
    | <OR: "or">
    | <IMPLIES: "->">
    | <AX: "AX">
    | <AF: "AF">
    | <AG: "AG">
    | <EX: "EX">
    | <EF: "EF">
    | <EG: "EG">
    | <A: "A">
    | <E: "E">
    | <U: "U">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <ATOM: ["a"-"z"](["0"-"9"])*>
}

/** Root production. Returns states in supplied kripke that hold for specified model */
Set Parse(Kripke kripke):
{
 this.kripke = kripke;
 Set f;
}
{
    f = formula(this.kripke.getStates()) <EOF>
    {
        return f;
    }
}

Set formula(Set states):
{
 Set e;
 Set b;
 Set stub = new HashSet();
}
{
    e = expression(states)  [ b = binaryPredicate(e, states) ]
    {
        // TODO since the lines below are expanding wrong, try moving all the binaryOperator logic here in formula()
        // if (b != null) return b;
        // else return e;
        return stub;
    }
}

Set expression(Set states):
{
 Token s;
 Set stub = new HashSet();
}
{
        s = <ATOM>
        {
            String labelStr = s.toString();
            Character label = labelStr.charAt(0);
            Set statesWithLabel = statesWithLabel(states,label);
            // Set statesWithLabel = statesWithLabel(this.kripke.getStates(),label);
            return statesWithLabel;
        }
    |   <NOT> formula(stub)
    |   <LPAREN> formula(stub) <RPAREN>
    |   temporalExpression()
}

Set binaryPredicate(Set binarySubject, Set states):
{ Set f; Set stub = new HashSet(); }
{
        <AND> f = formula(states)
        { /* TODO do intersection of binarySubject and f here */ return stub; }
    |   <OR> f = formula(states)
        { /* TODO do union of binarySubject and f here */ return stub; }
    |   <IMPLIES> f = formula(states)
        { /* TODO do ¬binarySubject ∨ f here */ return stub; }

}

void temporalExpression():
{ Set stub = new HashSet(); }
{
      <AX> formula(stub)
    | <AF> formula(stub)
    | <AG> formula(stub)
    | <EX> formula(stub)
    | <EF> formula(stub)
    | <EG> formula(stub)
    | <A> <LPAREN> formula(stub) <U> formula(stub) <RPAREN>
    | <E> <LPAREN> formula(stub) <U> formula(stub) <RPAREN>
}