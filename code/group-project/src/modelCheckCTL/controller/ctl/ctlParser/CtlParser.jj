options {
STATIC = false;
}

PARSER_BEGIN(CtlParser)
package modelCheckCTL.controller.ctl.ctlParser;

import java.util.Set;
import java.util.HashSet;
import modelCheckCTL.controller.ctl.ctlParser.ParseException;
import modelCheckCTL.model.ModelCheckInputs;
import modelCheckCTL.model.formulaObj.FormulaObj;
import static modelCheckCTL.controller.ctl.CtlUtils.statesWithLabel;
import static modelCheckCTL.controller.ctl.CtlUtils.union;
import modelCheckCTL.model.kripke.Kripke;

/* clt parser rules approach from https://github.com/pedrogongora/antelope/blob/master/AntelopeCore/src/antelope/ctl/parser/CTLParser.jj, accessed 9/20 */
public class CtlParser {
    Kripke kripke;
    String model;

    public CtlParser(ModelCheckInputs modelCheckInputs) {
	  this(modelCheckInputs.getStream(), null); // dunno what this call does exactly, but it's needed to avoid JavaCC throwing a null error. Compare to the autogenerated constructor in CtlValidator.java line 168
	  this.kripke = modelCheckInputs.getKripke();
	  this.model = modelCheckInputs.getCtlFormula();
    }

}

PARSER_END(CtlParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
      <NOT: "not">
    | <AND: "and">
    | <OR: "or">
    | <IMPLIES: "->">
    | <AX: "AX">
    | <AF: "AF">
    | <AG: "AG">
    | <EX: "EX">
    | <EF: "EF">
    | <EG: "EG">
    | <A: "A">
    | <E: "E">
    | <U: "U">
    | <LPAREN: "(">
    | <RPAREN: ")">
    | <ATOM: ["a"-"z"](["0"-"9"])*>
}

/** Root production. */
Set Parse():
{
    Set f;
}

{
    f = formula(kripke.getStates()) <EOF>
    { return f; }
}

Set formula(Set states):
{
    Set e;
    Set b = null;
}
{
    e = expression(states) [ b = binaryPredicate(e) ]
    {
        if (b != null) { return b; }
        else { return e; }
    }
}

Set expression(Set states):
{ Token t; }
{
        t = <ATOM>
        {
            Set statesWithLabels = statesWithLabel(states, t);
            // System.out.println(statesWithLabels);
            return statesWithLabels;
        }
    |   <NOT> formula(states)
        { return new HashSet(); }
    |   <LPAREN> formula(states) <RPAREN>
        { return new HashSet(); }
    |   temporalExpression(states)
        { return new HashSet(); }
}

Set binaryPredicate(Set subject):
{ Set predicate; }
{
        <AND> predicate = formula(subject)
        { return union(subject,predicate); }
    |   <OR> formula(subject)
        { return new HashSet(); }
    |   <IMPLIES> formula(subject)
        { return new HashSet(); }
}

void temporalExpression(Set s):
{}
{
      <AX> formula(s)
    | <AF> formula(s)
    | <AG> formula(s)
    | <EX> formula(s)
    | <EF> formula(s)
    | <EG> formula(s)
    | <A> <LPAREN> formula(s) <U> formula(s) <RPAREN>
    | <E> <LPAREN> formula(s) <U> formula(s) <RPAREN>
}